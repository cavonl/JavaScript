<!--
 * @Author: cavon 425247833@qq.com
 * @Date: 2023-11-22 23:20:11
 * @LastEditors: cavon 425247833@qq.com
 * @LastEditTime: 2023-11-23 20:40:26
 * @FilePath: /JavaScript/10_DOM/34_事件循环-消息队列.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件循环-消息队列</title>
</head>

<body>
  <button id="btn">点我一下</button>
  <button id="btn02">点我一下2</button>
  <!--
    二、
      这些正在执行的代码在调用堆栈里，还有一些代码它是等待执行的，也就是准备执行，但是由于栈还没空，js又是单线程的，必须得等到正在执行的代码执行完毕，等待执行的代码才能进入到栈内。

      等待执行的代码此时也会放在消息队列中，而调用栈里面放的函数、作用域、栈帧都有关系，fn2属于fn，fn属于全局，是有一个从属关系。

      由于btn.onclick函数跟fn2没有关系，此时将btn.onclick函数插入到栈顶，不合适，根本不合适。
      所以当事件触发以后，btn.onclick函数是没有权限直接往调用堆栈里面去整，因为整进去容易出乱，所以把它放到消息队列当中去排队。
   -->
   <br>
  <img src="./images/xiaoXiDuiLie.png" alt="消息队列" width="700">
  <br>
  <img src="./images/xiaoXiDuiLie2.png" alt="消息队列" width="700">
  <!--
    三、
      当我们点击按钮，事件触发，调用函数，调用函数是把这个函数插入到了消息队列当中，
      由于消息队列是空的，所以btn.onclick进入消息队列后排第一，但是它不能进入到调用堆栈中，因为调用堆栈不能确定一定是空的。

      那什么时候进入调用用堆栈呢？当我们的调用堆栈空了，fn2、fn、全局都没了，那么消息队列的函数就排队进入到调用堆栈中，就可以去执行了。

      那如果消息队列是空的，btn.onclick函数排第一，正好调用堆栈也是空的，所以就从消息队列中给它直接送到调用堆栈当中，所以这个时候我们的直观感受是立刻就执行了。
      1. 如果调用堆栈有东西，被占领了，这个时候btn.onclick就进不了调用堆栈，那么它就不能执行了
      2. 消息队列有很多排队的，如果没有排到btn.onclick，那么就进不了调用堆栈，那么它就不能执行了
      所以有的时候我们的事件它会出现一个延迟的情况，叫阻塞。它有可能被其他的事件给阻塞了
   -->

  <script>
    /*
      事件循环（event loop）
        - 函数在每次执行时，都会产生一个执行环境
        - 执行环境负责存储函数执行时产生的一切数据
        - 问题：函数的执行环境要存储到哪里呢？
            - 函数的执行环境存储到了一个叫做调用栈的地方
            - 栈，是一种数据结构，特点后进先出
            - 队列，是一种数据结构，特点先进先出

        调用栈（call stack）
          - 调用栈负责存储函数的执行环境
          - 当一个函数被调用时，它的执行环境会作为一个栈帧，插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出

        消息队列
          - 消息队列负责存储将要执行的函数
          - 当我们触发一个事件时，其响应函数并不是直接就添加到调用栈中的，因为调用栈中有可能会存在一些还没有执行完的代码
          - 事件触发后，JS引擎是将事件响应函数插入到消息队列中排队
     */

    // 函数代码按照顺序执行
    function fn() {
      let a = 10;
      let b = 10;

      function fn2() {
        console.log("fn2~");
      }
      fn2();

      console.log("fn~");
    }
    fn();

    // 全局代码
    console.log(1111);

    const btn = document.getElementById("btn");
    const btn02 = document.getElementById("btn02");
    /*
      一、
        此时多了btn.onclick这个函数，btn.onclick这个函数什么时候执行？
          当点击按钮的时候才会执行，也就是全局作用域中的所有代码都执行完了，最后才会执行。如果不点永远不会执行。

        当我们点击按钮的时候，事件触发函数要执行，函数执行就要添加到调用堆栈当中去，那么这个函数（btn.onclick）是怎么跑到调用堆栈里的？是直接进入调用堆栈去的吗？

     */
    // btn.onclick = function () {
    //   console.log("按钮被惦记了～～");
    // }

    btn.onclick = function () {
      alert("btn " + 1111);

      // 获取一个当前最新的时间戳
      const begin = Date.now();

      /*
        四、
          死循环，为什么要写一个死循环？当写了一个死循环后，循环会一直运行，那么循环就会一直在那个栈顶存在，一直占着，其他的代码就进不来，所以我们能看到一个代码的阻塞。

          在循环占用的过程中，如果在点击按钮，等于又触发了一下这个事件
       */
      while (Date.now() - begin < 3000) { }
    }

    /*
      五、
        正常情况下，点完btn02后，出现弹框2222，再次点击btn会立刻弹出1111。

        现在的情况是，我点完btn会弹出1111，会卡三秒，当我再点击btn02，弹框没有立刻出来，为什么没有立刻出来？
        因为有延迟，当我点击btn以后，在btn.onclick函数里面通过while循环让它停了三秒，
        意味着它实际上一直在占用着我们的调用堆栈，调用堆栈有东西，所以btn02进不去，一直在那卡着，触发不了。

        那btn02什么时候才能进去呢？当while循环执行完了，超过三秒，btn02才会进去。正好btn02排第一进栈了，然后btn02才会执行。

        如果当我先点击btn，出现效果以后，我再点击btn02三次，点三下实际上触发了三次事件，那这样意味着它要往队列里放三个，会出现三次弹框，为什么会出现三个？
        因为点击了三次按钮没有立刻执行。为什么没有立刻执行，因为被btn.onclick函数的while循环占着了。
        所以当btn02第一次执行的时候，btn在调用堆栈里，在btn停的三秒过程中，又点了btn02三下，这时3（btn02点击的3次） + 2（btn点击了一下，while循环占用了3秒）去哪了？去队列里排队。
        当btn执行完了，出栈了，队列里的btn02第一次点击进栈，第一次点击执行了，第二次点击进栈，第二次点击执行完了，第三次点击进栈，第三次点击执行完了，
     */
    btn02.onclick = function () {
      alert("btn02" + 2222);
    }

    /*
      总结：
        调用堆栈是来存储我们正在执行的函数的，叫执行环境。

        消息队列是我们将要执行时的东西，在消息队列中，一些东西排队等栈空了，它们再依次进栈执行，这个就是一个事件的循环机制
     */

  </script>
</body>

</html>