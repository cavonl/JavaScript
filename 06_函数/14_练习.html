<!--
 * @Author: chengfun 425247833@qq.com
 * @Date: 2023-09-17 11:34:20
 * @LastEditors: chengfun 425247833@qq.com
 * @LastEditTime: 2023-09-17 15:26:06
 * @FilePath: /JavaScript/06_函数/14_练习.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>练习</title>
  <script>
    console.log('练习1: ');
    var a = 1;
    function fn() {

      a = 2;
      console.log(a); // 2
    }
    fn();
    // 由于a重新赋值了，把全局变量a赋值为了2，所以最后得到的也是2
    console.log(a); // 2



    console.log('练习2: ');
    // 变量和函数的提升同样适用函数作用域
    var b = 1;
    function fn2() {
      // 解析器会把 var b; 放在前面，此时的b没有赋值所以为undefined
      console.log(b); // undefined
      var b = 2;
      console.log(b); // 2
    }
    fn2();
    console.log(b); // 1



    console.log('练习3: ');
    // 定义形参就相当于在函数中声明了对应的变量，但是没有赋值
    var c = 1;
    function fn3(c) {
      console.log(c); // undefined
      // var c = 2;
      c = 2;
      console.log(c); // 2
    }
    fn3();
    console.log(c); // 1



    console.log('练习4: ');
    var d = 1;
    function fn4(d) {
      console.log(d); // 10
      // var c = 2;
      d = 2;
      console.log(d); // 2
    }
    fn4(10);
    console.log(d); // 1


    console.log('练习5: ');
    var e = 1;
    function fn5(e) {
      console.log(e); // 1
      // var c = 2;
      e = 2;
      console.log(e); // 2
    }
    fn5(e);
    console.log(e); // 1



    console.log('练习6: ');
    console.log(f); // f() { alert(2); }

    var f = 1;
    console.log(f); // 1

    // 被提升了
    function f() {
      alert(2);
    }

    // 把前面的函数覆盖了
    // function f() {
    //   alert(5);
    // }

    console.log(f); // 1

    var f = 3;
    console.log(f); // 3

    var f = function () {
      alert(4);
    }
    console.log(f); // () => { alert(4); }

    // f = 5;
    // console.log(f); // 5

    // 被提升了，早就用完了
    var a;

    console.log(f); // () => { alert(4); }




  </script>
</head>

<body>

</body>

</html>